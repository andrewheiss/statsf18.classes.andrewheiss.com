---
title: "Wrapping up and going beyond the basics"
date: "2018-12-13"
citeproc: false
bibliography: ../../static/bib/references.bib
csl: ../../static/bib/chicago-syllabus-no-bib.csl
output:
  blogdown::html_page:
    template: ../../pandoc/toc-title_html.template
    toc: true
editor_options: 
  chunk_output_type: console
---

<!-- BLOGDOWN-HEAD -->
<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    background-color: #ffffff;
    color: #a0a0a0;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #a0a0a0;  padding-left: 4px; }
div.sourceCode
  { color: #1f1c1b; background-color: #ffffff; }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span. { color: #1f1c1b; } /* Normal */
code span.al { color: #bf0303; background-color: #f7e6e6; font-weight: bold; } /* Alert */
code span.an { color: #ca60ca; } /* Annotation */
code span.at { color: #0057ae; } /* Attribute */
code span.bn { color: #b08000; } /* BaseN */
code span.bu { color: #644a9b; font-weight: bold; } /* BuiltIn */
code span.cf { color: #1f1c1b; font-weight: bold; } /* ControlFlow */
code span.ch { color: #924c9d; } /* Char */
code span.cn { color: #aa5500; } /* Constant */
code span.co { color: #898887; } /* Comment */
code span.cv { color: #0095ff; } /* CommentVar */
code span.do { color: #607880; } /* Documentation */
code span.dt { color: #0057ae; } /* DataType */
code span.dv { color: #b08000; } /* DecVal */
code span.er { color: #bf0303; text-decoration: underline; } /* Error */
code span.ex { color: #0095ff; font-weight: bold; } /* Extension */
code span.fl { color: #b08000; } /* Float */
code span.fu { color: #644a9b; } /* Function */
code span.im { color: #ff5500; } /* Import */
code span.in { color: #b08000; } /* Information */
code span.kw { color: #1f1c1b; font-weight: bold; } /* Keyword */
code span.op { color: #1f1c1b; } /* Operator */
code span.ot { color: #006e28; } /* Other */
code span.pp { color: #006e28; } /* Preprocessor */
code span.re { color: #0057ae; background-color: #e0e9f8; } /* RegionMarker */
code span.sc { color: #3daee9; } /* SpecialChar */
code span.ss { color: #ff5500; } /* SpecialString */
code span.st { color: #bf0303; } /* String */
code span.va { color: #0057ae; } /* Variable */
code span.vs { color: #bf0303; } /* VerbatimString */
code span.wa { color: #bf0303; } /* Warning */
</style>
<!-- /BLOGDOWN-HEAD -->

<h2>Contents</h2>
<div id="TOC">
<ul>
<li><a href="#slides">Slides</a></li>
<li><a href="#logistic-regression">Logistic regression</a></li>
<li><a href="#algorithmic-complexity-and-mystery">Algorithmic complexity and mystery</a></li>
<li><a href="#sharing-graphics-code-and-analysis">Sharing graphics, code, and analysis</a></li>
</ul>
</div>

<h2 id="slides">Slides</h2>
<p>Download the slides from today’s lecture:</p>
<ul>
<li><a href="/slides/MPA-630_2018-12-13.pdf"><i class="fas fa-file-pdf"></i> PDF (best option)</a></li>
<li><a href="/slides/MPA-630_2018-12-13.pptx"><i class="fas fa-file-powerpoint"></i> PowerPoint</a></li>
</ul>
<figure>
<a href="/slides/MPA-630_2018-12-13.pdf"><img src="/images/slides/slides_2018-12-13.png" alt="First slide" /></a>
</figure>
<h2 id="logistic-regression">Logistic regression</h2>
<p>If you have an outcome variable that is binary (yes/no, agree/disagree, Obama/Romney, etc.), you cannot use standard linear regression. Instead, you need to use something called logistic regression. The math and mechanics of this type of regression are beyond the scope of this class, but you know enough about regression to be able to use it and interpret it.</p>
<p>To run logistic regression in R, we use <code>glm()</code> instead of <code>lm()</code>, but the structure is the same. The only difference is that we have to specify that this is logistic regression with the <code>family</code> option:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">glm</span>(y <span class="op">~</span><span class="st"> </span>x1 <span class="op">+</span><span class="st"> </span>x2 <span class="op">+</span><span class="st"> </span>x3, 
    <span class="dt">family =</span> <span class="kw">binomial</span>(<span class="dt">link =</span> <span class="st">&quot;logit&quot;</span>),
    <span class="dt">data =</span> whatever)</code></pre>
<p>The coefficients that come from this model behave a little differently than linear regression. Here’s an example using GSS data from your past problem sets.</p>
<p>First, we load libraries and clean the data:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)
<span class="kw">library</span>(broom)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">gss_raw &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;https://statsf18.classes.andrewheiss.com/data/gss2016.csv&quot;</span>, 
                <span class="dt">na =</span> <span class="kw">c</span>(<span class="st">&quot;&quot;</span>, <span class="st">&quot;Don&#39;t know&quot;</span>,
                       <span class="st">&quot;No answer&quot;</span>, <span class="st">&quot;Not applicable&quot;</span>),
                <span class="dt">guess_max =</span> <span class="dv">2867</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(marital, childs, educ, sex, race, born, income, pres12, polviews, pray)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">gss &lt;-<span class="st"> </span>gss_raw <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="co"># Look for the letters &quot;onservative&quot;. I omit the C because sometimes it&#39;s</span>
<span class="st">  </span><span class="co"># uppercase (Conservative) and sometimes it&#39;s lowercase (Slightly conservative)</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">polviews_ordered =</span> <span class="kw">factor</span>(polviews, 
                                   <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;Extrmly conservative&quot;</span>, <span class="st">&quot;Conservative&quot;</span>, 
                                              <span class="st">&quot;Slghtly conservative&quot;</span>, <span class="st">&quot;Moderate&quot;</span>,
                                              <span class="st">&quot;Slightly liberal&quot;</span>, <span class="st">&quot;Liberal&quot;</span>,
                                              <span class="st">&quot;Extremely liberal&quot;</span>),
                                   <span class="dt">ordered =</span> <span class="ot">TRUE</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">conservative =</span> <span class="kw">ifelse</span>(<span class="kw">str_detect</span>(polviews, <span class="st">&quot;onservative&quot;</span>),
                               <span class="st">&quot;Conservative&quot;</span>, <span class="st">&quot;Not conservative&quot;</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">marital2 =</span> <span class="kw">case_when</span>(
    marital <span class="op">==</span><span class="st"> &quot;Married&quot;</span> <span class="op">~</span><span class="st"> &quot;Married&quot;</span>,
    <span class="ot">TRUE</span> <span class="op">~</span><span class="st"> &quot;Not married&quot;</span>
  )) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="co"># Get rid of the respondents who didn&#39;t vote for Obama or Romney</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">pres12 =</span> <span class="kw">ifelse</span>(<span class="op">!</span>pres12 <span class="op">%in%</span><span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Obama&quot;</span>, <span class="st">&quot;Romney&quot;</span>), <span class="ot">NA</span>, pres12)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">pres12 =</span> <span class="kw">factor</span>(pres12)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="co"># case_when is like a fancy version of an if statement and it lets us collapse</span>
<span class="st">  </span><span class="co"># the different levels of pray into two</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">pray2 =</span> <span class="kw">case_when</span>(
    pray <span class="op">==</span><span class="st"> &quot;Several times a day&quot;</span> <span class="op">~</span><span class="st"> &quot;At least once a week&quot;</span>,
    pray <span class="op">==</span><span class="st"> &quot;Once a day&quot;</span> <span class="op">~</span><span class="st"> &quot;At least once a week&quot;</span>,
    pray <span class="op">==</span><span class="st"> &quot;Several times a week&quot;</span> <span class="op">~</span><span class="st"> &quot;At least once a week&quot;</span>,
    pray <span class="op">==</span><span class="st"> &quot;Once a week&quot;</span> <span class="op">~</span><span class="st"> &quot;At least once a week&quot;</span>,
    pray <span class="op">==</span><span class="st"> &quot;Lt once a week&quot;</span> <span class="op">~</span><span class="st"> &quot;Less than once a week&quot;</span>,
    pray <span class="op">==</span><span class="st"> &quot;Never&quot;</span> <span class="op">~</span><span class="st"> &quot;Less than once a week&quot;</span>,
    pray <span class="op">==</span><span class="st"> &quot;Don&#39;t know&quot;</span> <span class="op">~</span><span class="st"> </span><span class="ot">NA_character_</span>,
    pray <span class="op">==</span><span class="st"> &quot;No answer&quot;</span> <span class="op">~</span><span class="st"> </span><span class="ot">NA_character_</span>,
    pray <span class="op">==</span><span class="st"> &quot;Not applicable&quot;</span> <span class="op">~</span><span class="st"> </span><span class="ot">NA_character_</span>
  )) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">pray2 =</span> <span class="kw">factor</span>(pray2, 
                        <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;Less than once a week&quot;</span>, <span class="st">&quot;At least once a week&quot;</span>))) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="co"># Make this numeric</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">childs =</span> <span class="kw">as.numeric</span>(childs))</code></pre>
<p>We’ll use this data to find the factors that made people more likely to vote for Mitt Romney in 2016. Our outcome variable (or Y) is <code>pres12</code>, which has two values: Obama and Romney. Because it’s not numeric, and because there are two possible categories, we’ll use logistic regression. We’ll explain 2012 presidential votes based on the number of children people have, marital status, conservativeness, and frequency of prayer</p>
<pre class="sourceCode r"><code class="sourceCode r">model_logit &lt;-<span class="st"> </span><span class="kw">glm</span>(pres12 <span class="op">~</span><span class="st"> </span>childs <span class="op">+</span><span class="st"> </span>marital <span class="op">+</span><span class="st"> </span>conservative <span class="op">+</span><span class="st"> </span>pray2, 
                   <span class="dt">family =</span> <span class="kw">binomial</span>(<span class="dt">link =</span> <span class="st">&quot;logit&quot;</span>), <span class="dt">data =</span> gss)</code></pre>
<p>The <code>get_regression_table()</code> from the ModernDive package only works on linear models made with <code>lm()</code>, but we can get the same thing if we use a function named <code>tidy()</code> from <code>library(broom)</code>. Technically, <code>get_regression_table()</code> is really just <code>tidy()</code> behind the scenes—the ModernDive authors just renamed it to make it easier for you.</p>
<p>The coefficients that come from this model are uninterpretable initially. The numbers are in a scale called “log odds”, which is a side effect of the math used to run the logistic regression:</p>
<pre class="sourceCode r"><code class="sourceCode r">model_logit <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">tidy</span>()</code></pre>
<pre><code>## # A tibble: 8 x 5
##   term                         estimate std.error statistic  p.value
##   &lt;chr&gt;                           &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;
## 1 (Intercept)                    0.828     0.234      3.54  3.93e- 4
## 2 childs                        -0.102     0.0462    -2.22  2.66e- 2
## 3 maritalMarried                 0.411     0.175      2.35  1.86e- 2
## 4 maritalNever married          -0.693     0.225     -3.08  2.08e- 3
## 5 maritalSeparated              -0.477     0.425     -1.12  2.62e- 1
## 6 maritalWidowed                 0.0705    0.246      0.287 7.74e- 1
## 7 conservativeNot conservative  -2.59      0.131    -19.8   1.35e-87
## 8 pray2At least once a week      0.219     0.162      1.35  1.77e- 1</code></pre>
<p>To transform these numbers to something interpretable, we have to unlog them. This will create something called an “odds ratio”, which shows the change in probability of the Y outcome happening.</p>
<p>The coefficients were logged using a natural log (<span class="math inline">\(ln\)</span> or <span class="math inline">\(\log_e\)</span>), so to unlog them, we need to take <span class="math inline">\(e\)</span> and raise it to the power of each coefficient. If a log odds coefficient is 0.411, like the married coefficient, we can unlog it by calculating <span class="math inline">\(e^{0.411}\)</span>, which is 1.508. You can use the <code>exp()</code> function in R to do this: <code>exp(0.411)</code> is 1.508.</p>
<p>Running <code>exp()</code> on every coefficient, though, is tedious. Fortunately, the <code>tidy()</code> function has an option that will do that for you. We can also get confidence intervals by setting the <code>conf.int</code> option:</p>
<pre class="sourceCode r"><code class="sourceCode r">model_logit <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">tidy</span>(<span class="dt">exponentiate =</span> <span class="ot">TRUE</span>, <span class="dt">conf.int =</span> <span class="ot">TRUE</span>)</code></pre>
<pre><code>## # A tibble: 8 x 7
##   term             estimate std.error statistic  p.value conf.low conf.high
##   &lt;chr&gt;               &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;
## 1 (Intercept)        2.29      0.234      3.54  3.93e- 4   1.45      3.62  
## 2 childs             0.903     0.0462    -2.22  2.66e- 2   0.824     0.988 
## 3 maritalMarried     1.51      0.175      2.35  1.86e- 2   1.07      2.13  
## 4 maritalNever ma…   0.500     0.225     -3.08  2.08e- 3   0.321     0.776 
## 5 maritalSeparated   0.620     0.425     -1.12  2.62e- 1   0.263     1.40  
## 6 maritalWidowed     1.07      0.246      0.287 7.74e- 1   0.662     1.74  
## 7 conservativeNot…   0.0750    0.131    -19.8   1.35e-87   0.0579    0.0966
## 8 pray2At least o…   1.24      0.162      1.35  1.77e- 1   0.908     1.71</code></pre>
<p>These are the actual coefficients we can interpret. The final trick is that <em>these numbers are all based around 1.</em> Values higher than 1 mean that the explanatory variables are associated with a greater probability of Romney votes; values less than 1 mean that the explanatory variables are associated with a lower probability of Romney votes.</p>
<p>Here’s how to interpret a bunch of these coefficients:</p>
<ul>
<li>The coefficient for married people is 1.51. This means that compared to divorced people (the base case for <code>marital</code>) people who are married are 51% more likely to have voted for Romney in 2012. That coefficient is statistically significant, and the confidence interval does not include 1.</li>
<li>The coefficient for children is 0.9. This means that for every additional child someone has, the probability of voting for Romney in 2012 <em>decreases</em> 10% (since 1 − 0.9 is 0.1). This is also statistically significant; the confidence interval does not include 1.</li>
<li>The coefficient for conservative is 0.075. This means that people who aren’t conservative are 93% less likely to have voted for Romney in 2012 (since 1 − 0.075 = 0.925). This is statistically significant.</li>
<li>The coefficient for prayer is 1.24, which means that praying at least once a week is associated with at 24% greater chance of voting for Romney in 2012. This is not statistically significant, though—the p-value is 0.177, and the confidence interval contains 1.</li>
</ul>
<p>The key is that everything is centered around 1. If the odds ratio is something like 0.4, it means that the Y outcome is 60% less likely (since 1 − 0.4 = 0.6). If the odds ratio is something like 1.8, it means that the Y outcome is 80% more likely (since 1.8 is 0.8 greater than 1). If the odds ratio is something big like 7.3, it means that the Y outcome is 7.3 <em>times</em> more likely.</p>
<h2 id="algorithmic-complexity-and-mystery">Algorithmic complexity and mystery</h2>
<p>Logistic regression is the foundation for tons of what happens on the internet. Companies want to predict if you’ll click on an ad, donated to a political campaign, buy a product, etc., and each of these outcomes is binary (click/don’t click, donate/don’t donate, buy/don’t buy). Simple algorithms use logistic regression to find the factors that influence the decision to click, donate, or buy.</p>
<p>More complex algorithms go beyond logistic regression and use complicated math to make these predictions. While these algorithms generally make arguably better predictions,<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">Though not always! <a href="https://arxiv.org/abs/1806.06850">This paper finds that basic logistic regression can often perform just as well as complicated black box models</a>.<br />
<br />
</span></span> they sacrifice accuracy for interpretability. This, in turn, can lead to all sorts of ethical issues and cause bias to get baked into these models.</p>
<p>We didn’t have time to watch this in class, but this is a fantastic short video explaining this process:</p>
<figure>
{{% youtube "BSpAWkQLlgM" %}}
</figure>
<h2 id="sharing-graphics-code-and-analysis">Sharing graphics, code, and analysis</h2>
<ul>
<li><a href="https://rpubs.com/">Publishing at RPubs</a></li>
<li><a href="https://github.com/">GitHub</a> and <a href="https://gist.github.com/">Gists</a></li>
</ul>
<p>Entire projects:</p>
<ul>
<li><a href="https://bookdown.org/yihui/rmarkdown/rmarkdown-site.html">RMarkdown websites</a> (see <a href="http://jamessinkovic.net/capstone/index.html">James Sinkovic’s MPA capstone project</a>)</li>
<li><a href="https://bookdown.org/yihui/blogdown/">Blogdown</a></li>
<li><a href="https://bookdown.org/">Bookdown</a></li>
</ul>
